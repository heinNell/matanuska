/**
 * Tyre Integration Service
 * Handles external integrations and automation for the tyre management system
 */

import {
  addDoc,
  collection,
  doc,
  updateDoc,
  serverTimestamp,
  query,
  where,
  getDocs,
} from "firebase/firestore";
import { firestore } from "../firebase";
import { Tyre, TyreInspection } from "../types/tyre";

// Vendor API Integration Types
export interface VendorPriceQuote {
  vendorId: string;
  vendorName: string;
  brand: string;
  pattern: string;
  size: string;
  price: number;
  currency: string;
  availability: "in_stock" | "order_required" | "out_of_stock";
  leadTime: number; // days
  validUntil: string;
  lastUpdated: string;
}

export interface VendorAPIResponse {
  success: boolean;
  data?: VendorPriceQuote[];
  error?: string;
  timestamp: string;
}

// Tyre specification interface for vendor API calls
export interface TyreSpecification {
  brand: string;
  pattern: string;
  size: string;
  quantity: number;
}

// Report data interface
export interface ReportData {
  reportName: string;
  generatedAt: string;
  data: Record<string, unknown>[];
}

// Telematics Integration Types
export interface TelematicsUpdate {
  vehicleId: string;
  fleetNumber: string;
  currentMileage: number;
  lastPosition: {
    latitude: number;
    longitude: number;
    timestamp: string;
  };
  engineHours: number;
  fuelLevel: number;
  diagnosticCodes: string[];
}

// Job Card Generation Types
export interface AutoGeneratedJobCard {
  id: string;
  fleetNumber: string;
  tyrePosition: string;
  priority: "low" | "medium" | "high" | "critical";
  taskType: "inspection" | "replacement" | "rotation" | "repair";
  estimatedDuration: number; // hours
  requiredParts: string[];
  description: string;
  createdFrom: "inspection" | "telematics" | "schedule";
  sourceInspectionId?: string;
  autoGenerated: boolean;
  scheduledDate?: string;
}

// Report Automation Types
export interface ScheduledReport {
  id: string;
  name: string;
  type: "daily" | "weekly" | "monthly" | "quarterly";
  schedule: string; // cron expression
  recipients: string[];
  filters: {
    fleetNumbers?: string[];
    vehicleTypes?: string[];
    dateRange?: {
      start: string;
      end: string;
    };
  };
  format: "pdf" | "excel" | "csv";
  lastRun?: string;
  nextRun: string;
  enabled: boolean;
}

class TyreIntegrationService {
  private vendorAPIs = new Map<string, string>([
    ["FTS001", "https://api.fieldtyreservices.co.za/v1"],
    ["ITS001", "https://api.impalatruckspares.co.za/v1"],
    ["PT001", "https://api.protyre.co.za/v1"],
    // Add more vendor API endpoints as they become available
  ]);

  /**
   * Vendor API Integration
   */
  async getVendorPricing(tyreSpec: TyreSpecification): Promise<VendorPriceQuote[]> {
    const quotes: VendorPriceQuote[] = [];

    for (const [vendorId, apiUrl] of this.vendorAPIs) {
      try {
        const response = await this.fetchVendorQuote(vendorId, apiUrl, tyreSpec);
        if (response.success && response.data) {
          quotes.push(...response.data);
        }
      } catch (error) {
        console.warn(`Failed to get quote from vendor ${vendorId}:`, error);
        // Continue with other vendors
      }
    }

    // Store quotes in Firestore for caching
    await this.cacheVendorQuotes(quotes);

    return quotes.sort((a, b) => a.price - b.price); // Sort by price
  }

  private async fetchVendorQuote(
    vendorId: string,
    apiUrl: string,
    tyreSpec: TyreSpecification
  ): Promise<VendorAPIResponse> {
    // Simulate API call - replace with actual vendor API integration
    await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate network delay

    // Mock response - replace with actual API call
    const mockQuote: VendorPriceQuote = {
      vendorId,
      vendorName: this.getVendorName(vendorId),
      brand: tyreSpec.brand,
      pattern: tyreSpec.pattern,
      size: tyreSpec.size,
      price: Math.floor(Math.random() * 2000) + 1000, // Random price between 1000-3000
      currency: "ZAR",
      availability: Math.random() > 0.7 ? "in_stock" : "order_required",
      leadTime: Math.floor(Math.random() * 14) + 1,
      validUntil: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      lastUpdated: new Date().toISOString(),
    };

    return {
      success: true,
      data: [mockQuote],
      timestamp: new Date().toISOString(),
    };
  }

  private async cacheVendorQuotes(quotes: VendorPriceQuote[]): Promise<void> {
    const batch = quotes.map((quote) =>
      addDoc(collection(firestore, "vendorQuotes"), {
        ...quote,
        cachedAt: serverTimestamp(),
      })
    );

    await Promise.all(batch);
  }

  /**
   * Fleet Telematics Integration
   */
  async updateTyreMileageFromTelematics(): Promise<void> {
    try {
      // Get all vehicles with mounted tyres
      const vehiclesQuery = query(
        collection(firestore, "tyres"),
        where("mountStatus", "==", "mounted"),
        where("installation.vehicleId", "!=", null)
      );

      const tyresSnapshot = await getDocs(vehiclesQuery);
      const tyresWithVehicles = tyresSnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Tyre[];

      // Group by vehicle
      const vehicleGroups = tyresWithVehicles.reduce(
        (acc, tyre) => {
          const vehicleId = tyre.installation?.vehicleId;
          if (vehicleId) {
            if (!acc[vehicleId]) acc[vehicleId] = [];
            acc[vehicleId].push(tyre);
          }
          return acc;
        },
        {} as Record<string, Tyre[]>
      );

      // Update mileage for each vehicle
      for (const [vehicleId, tyres] of Object.entries(vehicleGroups)) {
        try {
          const telematicsData = await this.fetchTelematics(vehicleId);
          if (telematicsData) {
            await this.updateTyreMileage(tyres, telematicsData);
          }
        } catch (error) {
          console.warn(`Failed to update mileage for vehicle ${vehicleId}:`, error);
        }
      }
    } catch (error) {
      console.error("Error updating tyre mileage from telematics:", error);
      throw error;
    }
  }

  private async fetchTelematics(vehicleId: string): Promise<TelematicsUpdate | null> {
    try {
      // This would integrate with your existing Wialon API or telematics provider
      // For now, simulate the data
      const mockTelematicsData: TelematicsUpdate = {
        vehicleId,
        fleetNumber: vehicleId,
        currentMileage: Math.floor(Math.random() * 100000) + 50000,
        lastPosition: {
          latitude: -18.9292 + (Math.random() - 0.5) * 0.1,
          longitude: 32.8522 + (Math.random() - 0.5) * 0.1,
          timestamp: new Date().toISOString(),
        },
        engineHours: Math.floor(Math.random() * 5000) + 1000,
        fuelLevel: Math.floor(Math.random() * 100),
        diagnosticCodes: [],
      };

      return mockTelematicsData;
    } catch (error) {
      console.error(`Error fetching telematics for vehicle ${vehicleId}:`, error);
      return null;
    }
  }

  private async updateTyreMileage(tyres: Tyre[], telematicsData: TelematicsUpdate): Promise<void> {
    const updatePromises = tyres.map(async (tyre) => {
      const installationMileage = tyre.installation?.mileageAtInstallation || 0;
      const currentMileage = telematicsData.currentMileage;
      const kmRun = Math.max(0, currentMileage - installationMileage);

      return updateDoc(doc(firestore, "tyres", tyre.id), {
        kmRun,
        "condition.lastTelematiicsUpdate": serverTimestamp(),
        lastUpdated: serverTimestamp(),
      });
    });

    await Promise.all(updatePromises);
  }

  /**
   * Automated Job Card Generation
   */
  async generateJobCardFromInspection(inspection: TyreInspection): Promise<string | null> {
    try {
      // Determine if job card generation is needed
      const priority = this.calculatePriority(inspection);
      if (priority === "low") {
        return null; // No job card needed for low priority issues
      }

      const jobCard: AutoGeneratedJobCard = {
        id: `AUTO-${Date.now()}`,
        fleetNumber: inspection.vehicleId || "Unknown",
        tyrePosition: inspection.position || "Unknown",
        priority,
        taskType: this.determineTaskType(inspection),
        estimatedDuration: this.estimateDuration(inspection),
        requiredParts: this.determineRequiredParts(inspection),
        description: this.generateDescription(inspection),
        createdFrom: "inspection",
        sourceInspectionId: inspection.id,
        autoGenerated: true,
        scheduledDate: this.calculateScheduledDate(priority),
      };

      // Save to Firestore
      const docRef = await addDoc(collection(firestore, "jobCards"), {
        ...jobCard,
        createdAt: serverTimestamp(),
        status: "pending",
        assignedTo: null,
        completedAt: null,
      });

      // Create notification
      await this.createJobCardNotification(jobCard);

      return docRef.id;
    } catch (error) {
      console.error("Error generating job card from inspection:", error);
      throw error;
    }
  }

  private calculatePriority(inspection: TyreInspection): "low" | "medium" | "high" | "critical" {
    if (inspection.condition === "critical" || inspection.treadDepth < 3) {
      return "critical";
    }
    if (inspection.condition === "needs_replacement" || inspection.treadDepth < 5) {
      return "high";
    }
    if (inspection.condition === "warning" || inspection.treadDepth < 8) {
      return "medium";
    }
    return "low";
  }

  private determineTaskType(
    inspection: TyreInspection
  ): "inspection" | "replacement" | "rotation" | "repair" {
    if (inspection.condition === "critical" || inspection.treadDepth < 3) {
      return "replacement";
    }
    if (inspection.notes?.toLowerCase().includes("rotation")) {
      return "rotation";
    }
    if (inspection.notes?.toLowerCase().includes("repair")) {
      return "repair";
    }
    return "inspection";
  }

  private estimateDuration(inspection: TyreInspection): number {
    const taskType = this.determineTaskType(inspection);
    switch (taskType) {
      case "replacement":
        return 2;
      case "rotation":
        return 1.5;
      case "repair":
        return 1;
      case "inspection":
        return 0.5;
      default:
        return 1;
    }
  }

  private determineRequiredParts(inspection: TyreInspection): string[] {
    const parts: string[] = [];
    const taskType = this.determineTaskType(inspection);

    if (taskType === "replacement") {
      parts.push("New Tyre", "Valve Stem", "Wheel Weights");
    }
    if (taskType === "repair") {
      parts.push("Tyre Patch Kit", "Valve Core");
    }

    return parts;
  }

  private generateDescription(inspection: TyreInspection): string {
    const priority = this.calculatePriority(inspection);
    const taskType = this.determineTaskType(inspection);

    let description = `${priority.toUpperCase()} PRIORITY: ${taskType} required for tyre at position ${inspection.position}.`;
    description += ` Current tread depth: ${inspection.treadDepth}mm.`;

    if (inspection.notes) {
      description += ` Inspector notes: ${inspection.notes}`;
    }

    return description;
  }

  private calculateScheduledDate(priority: "low" | "medium" | "high" | "critical"): string {
    const now = new Date();
    const daysToAdd = {
      critical: 0, // Immediate
      high: 1,
      medium: 3,
      low: 7,
    }[priority];

    const scheduledDate = new Date(now.getTime() + daysToAdd * 24 * 60 * 60 * 1000);
    return scheduledDate.toISOString();
  }

  private async createJobCardNotification(jobCard: AutoGeneratedJobCard): Promise<void> {
    await addDoc(collection(firestore, "notifications"), {
      type: "job_card_created",
      title: `${jobCard.priority.toUpperCase()} Job Card Generated`,
      message: `Auto-generated job card for ${jobCard.fleetNumber} - ${jobCard.tyrePosition}`,
      priority: jobCard.priority,
      data: { jobCardId: jobCard.id },
      read: false,
      createdAt: serverTimestamp(),
    });
  }

  /**
   * Advanced Reporting with Scheduling
   */
  async scheduleReport(reportConfig: ScheduledReport): Promise<string> {
    try {
      const docRef = await addDoc(collection(firestore, "scheduledReports"), {
        ...reportConfig,
        createdAt: serverTimestamp(),
        lastRun: null,
      });

      // Schedule the report execution (this would integrate with a job scheduler)
      await this.scheduleReportExecution(docRef.id, reportConfig);

      return docRef.id;
    } catch (error) {
      console.error("Error scheduling report:", error);
      throw error;
    }
  }

  private async scheduleReportExecution(reportId: string, config: ScheduledReport): Promise<void> {
    // This would integrate with a job scheduler like Firebase Functions with Pub/Sub
    // For now, we'll simulate scheduling
    console.log(`Scheduled report ${reportId} with schedule: ${config.schedule}`);

    // Store in a simple scheduling collection for now
    await addDoc(collection(firestore, "reportSchedule"), {
      reportId,
      schedule: config.schedule,
      nextRun: config.nextRun,
      enabled: config.enabled,
      createdAt: serverTimestamp(),
    });
  }

  async generateScheduledReports(): Promise<void> {
    try {
      // Get all enabled scheduled reports that are due
      const now = new Date();
      const reportsQuery = query(
        collection(firestore, "scheduledReports"),
        where("enabled", "==", true),
        where("nextRun", "<=", now.toISOString())
      );

      const reportsSnapshot = await getDocs(reportsQuery);

      for (const reportDoc of reportsSnapshot.docs) {
        const report = reportDoc.data() as ScheduledReport;
        try {
          await this.executeScheduledReport(reportDoc.id, report);
        } catch (error) {
          console.error(`Error executing scheduled report ${reportDoc.id}:`, error);
        }
      }
    } catch (error) {
      console.error("Error generating scheduled reports:", error);
      throw error;
    }
  }

  private async executeScheduledReport(reportId: string, config: ScheduledReport): Promise<void> {
    // Generate the report data
    const reportData = await this.generateReportData(config);

    // Create the report file
    const reportUrl = await this.createReportFile(reportData, config.format);

    // Send to recipients
    await this.sendReportToRecipients(reportUrl, config);

    // Update last run and calculate next run
    const nextRun = this.calculateNextRun(config.schedule);
    await updateDoc(doc(firestore, "scheduledReports", reportId), {
      lastRun: serverTimestamp(),
      nextRun: nextRun.toISOString(),
    });
  }

  private async generateReportData(config: ScheduledReport): Promise<ReportData> {
    // This would generate actual report data based on the config
    // For now, return mock data
    return {
      reportName: config.name,
      generatedAt: new Date().toISOString(),
      data: [], // Would contain actual tyre data
    };
  }

  private async createReportFile(data: ReportData, format: string): Promise<string> {
    // This would create the actual file (PDF, Excel, CSV)
    // For now, return a mock URL
    return `https://reports.matanuska.com/tyre-reports/${Date.now()}.${format}`;
  }

  private async sendReportToRecipients(reportUrl: string, config: ScheduledReport): Promise<void> {
    // This would send emails or notifications to recipients
    console.log(`Sending report ${reportUrl} to:`, config.recipients);
  }

  private calculateNextRun(_schedule: string): Date {
    // Simple schedule calculation - would use a proper cron parser in production
    const now = new Date();
    return new Date(now.getTime() + 24 * 60 * 60 * 1000); // Add 1 day for now
  }

  /**
   * Utility Methods
   */
  private getVendorName(vendorId: string): string {
    const vendorNames = {
      FTS001: "Field Tyre Services",
      ITS001: "Impala Truck Spares",
      PT001: "Protyre Mutare",
    } as const;

    type VendorId = keyof typeof vendorNames;
    return vendorNames[vendorId as VendorId] || "Unknown Vendor";
  }

  /**
   * Integration Health Check
   */
  async checkIntegrationHealth(): Promise<{
    vendorAPIs: Record<string, boolean>;
    telematics: boolean;
    jobCardGeneration: boolean;
    reportScheduling: boolean;
  }> {
    const health = {
      vendorAPIs: {} as Record<string, boolean>,
      telematics: false,
      jobCardGeneration: false,
      reportScheduling: false,
    };

    // Check vendor APIs
    for (const [vendorId] of this.vendorAPIs) {
      try {
        // Simulate health check
        health.vendorAPIs[vendorId] = Math.random() > 0.1; // 90% uptime simulation
      } catch {
        health.vendorAPIs[vendorId] = false;
      }
    }

    // Check telematics
    try {
      health.telematics = true; // Would check actual telematics connection
    } catch {
      health.telematics = false;
    }

    // Check job card generation
    try {
      health.jobCardGeneration = true; // Would check Firestore connection
    } catch {
      health.jobCardGeneration = false;
    }

    // Check report scheduling
    try {
      health.reportScheduling = true; // Would check scheduler health
    } catch {
      health.reportScheduling = false;
    }

    return health;
  }
}

// Export singleton instance
export const tyreIntegrationService = new TyreIntegrationService();
export default TyreIntegrationService;
