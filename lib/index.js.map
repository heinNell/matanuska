{"version":3,"file":"index.js","sourceRoot":"","sources":["../functions/src/index.ts"],"names":[],"mappings":"AAAA;;;;;;;GAOG;AAEH,OAAO,EAAC,gBAAgB,EAAC,MAAM,oBAAoB,CAAC;AAIpD,0BAA0B;AAC1B,wDAAwD;AAExD,6EAA6E;AAC7E,yEAAyE;AACzE,qEAAqE;AACrE,6EAA6E;AAC7E,wDAAwD;AACxD,2DAA2D;AAC3D,0EAA0E;AAC1E,6EAA6E;AAC7E,4EAA4E;AAC5E,qDAAqD;AACrD,gBAAgB,CAAC,EAAE,YAAY,EAAE,EAAE,EAAE,CAAC,CAAC;AAEvC,+DAA+D;AAC/D,wDAAwD;AACxD,2CAA2C;AAC3C,MAAM","sourcesContent":["/**\n * Import function triggers from their respective submodules:\n *\n * import {onCall} from \"firebase-functions/v2/https\";\n * import {onDocumentWritten} from \"firebase-functions/v2/firestore\";\n *\n * See a full list of supported triggers at https://firebase.google.com/docs/functions\n */\n\nimport {setGlobalOptions} from \"firebase-functions\";\nimport {onRequest} from \"firebase-functions/https\";\nimport * as logger from \"firebase-functions/logger\";\n\n// Start writing functions\n// https://firebase.google.com/docs/functions/typescript\n\n// For cost control, you can set the maximum number of containers that can be\n// running at the same time. This helps mitigate the impact of unexpected\n// traffic spikes by instead downgrading performance. This limit is a\n// per-function limit. You can override the limit for each function using the\n// `maxInstances` option in the function's options, e.g.\n// `onRequest({ maxInstances: 5 }, (req, res) => { ... })`.\n// NOTE: setGlobalOptions does not apply to functions using the v1 API. V1\n// functions should each use functions.runWith({ maxInstances: 10 }) instead.\n// In the v1 API, each function can only serve one request per container, so\n// this will be the maximum concurrent request count.\nsetGlobalOptions({ maxInstances: 10 });\n\n// export const helloWorld = onRequest((request, response) => {\n//   logger.info(\"Hello logs!\", {structuredData: true});\n//   response.send(\"Hello from Firebase!\");\n// });\n"]}